# Saga 設計模式（分散式事務 / 最終一致性）—名詞消歧用

本頁的 **Saga** 指的是微服務/分散式系統中的 **Saga Design Pattern**（長交易 LLT 的最終一致性方案），用途主要是避免與本 repo 的「SAGA 智能體」混用名詞。[1]

---

## 1) 一句話定義

Saga 設計模式把「全域分散式事務」拆成一連串可獨立提交的**本地事務**；當中任一步失敗時，透過對應的**補償事務**撤銷先前已提交的效果，以換取最終一致性並避免 2PC 的高耦合與可用性問題。[1]

---

## 2) 兩種協作拓樸

### Orchestration（編排）
由中央協調器（Orchestrator）依序指揮各服務執行本地事務/補償事務。  
常見落點：可持久化狀態機 / durable execution（例如 Temporal、Camunda、Step Functions）。[1]

### Choreography（編舞）
沒有中央協調器；各服務用事件（Event）互相觸發下一步，失敗時同樣以事件驅動補償流程。  
常見落點：Kafka / RabbitMQ 等 event bus。[1]

---

## 3) 你需要特別小心的工程事實（常踩雷）

- **補償事務不等於 rollback**：補償通常是「業務層的反向操作」，要考慮外部副作用與不可逆行為。
- **冪等性與重試**：分散式環境不可避免重送；每一步與補償步都必須設計冪等或可去重。
- **語義鎖 / 競態控制**：要處理並行寫入、讀到中間狀態、以及跨服務一致性窗口。
- **觀測性**：你需要能追出 saga instance 的每一步與補償原因，否則排障成本極高。[1]

---

## 4) 與本 repo 的關係（避免誤會）

本 repo 有一個名為 `orchestrator/` 的服務，但它是「Web client ↔ SGLang ↔ ws_gateway_tts」的串流協調器；  
它**不代表**此 repo 在實作「分散式事務的 Saga pattern」。兩者概念不同，僅名稱相似。[1]

---

## Sources

- [1] 使用者提供的四域 SAGA 定義與回應原則（對話提示詞，2026-01-23）

